name: PR Automation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]

permissions:
  pull-requests: write
  contents: read

jobs:
  # Auto-label by files changed
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const labels = new Set();

            for (const file of files) {
              // Component labels
              if (file.filename.startsWith('apps/web/')) {
                labels.add('component:frontend');
              }
              if (file.filename.startsWith('apps/server/')) {
                labels.add('component:backend');
              }
              if (file.filename.startsWith('apps/server/prisma/')) {
                labels.add('component:database');
              }
              
              // Type labels
              if (file.filename.endsWith('.md')) {
                labels.add('documentation');
              }
              if (/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(file.filename)) {
                labels.add('testing');
              }
              if (file.filename.startsWith('.github/workflows/')) {
                labels.add('ci/cd');
              }
            }

            if (labels.size > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: Array.from(labels)
              });
            }

  # Check PR size and warn if too large
  size-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });

            const totalChanges = files.reduce((sum, file) => sum + file.changes, 0);
            let sizeLabel = '';

            if (totalChanges < 10) sizeLabel = 'size/xs';
            else if (totalChanges < 100) sizeLabel = 'size/s';
            else if (totalChanges < 500) sizeLabel = 'size/m';
            else if (totalChanges < 1000) sizeLabel = 'size/l';
            else sizeLabel = 'size/xl';

            // Remove old size labels
            const currentLabels = pr.labels.map(l => l.name);
            const sizeLabels = currentLabels.filter(l => l.startsWith('size/'));

            for (const label of sizeLabels) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                name: label
              }).catch(error => {
                console.log('Failed to remove label:', label, error && error.message ? error.message : error);
              });
            }

            // Add new size label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: [sizeLabel]
            });

            // Warn on large PRs
            if (totalChanges > 500) {
              const existingComments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
              });

              const botComment = existingComments.data.find(
                comment => comment.user.type === 'Bot' && comment.body.includes('large PR')
              );

              if (!botComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: `‚ö†Ô∏è **Large PR Warning**\n\nThis PR has **${totalChanges} changes**. Consider splitting it into smaller PRs for easier review.\n\n**Tips:**\n- Break into logical chunks\n- Separate refactoring from features\n- Keep PRs under 500 lines when possible`
                });
              }
            }

  # Enforce PR description quality
  check-description:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';

            const issues = [];

            // Check minimum length
            if (body.trim().length < 20) {
              issues.push('‚ùå PR description is too short (minimum 20 characters)');
            }

            // Check for issue link
            const closingKeywordIssuePattern = /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)s?\s*:?\s*#\d+/i;
            const shorthandIssuePattern = /(?:^|\s)#\d+(?:\s|$)/;
            const hasIssueLink = closingKeywordIssuePattern.test(body) || shorthandIssuePattern.test(body);
            if (!hasIssueLink) {
              issues.push('üí° Consider linking an issue using "Closes #123" or "Fixes #456"');
            }

            // Check for test mention if code changed
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });

            const hasCodeChanges = files.some(f => 
              f.filename.endsWith('.ts') || 
              f.filename.endsWith('.tsx') ||
              f.filename.endsWith('.js')
            );

            const hasTestChanges = files.some(f =>
              /\.(test|spec)\.(ts|tsx|js|jsx)$/.test(f.filename)
            );

            const bodyLower = body.toLowerCase();
            const mentionsTestsExplicitly =
              /(tests?\s+(added|updated|written|cover|covered|covering))|covered by existing tests|no tests (needed|required)|tests?\s+not\s+required/gi.test(bodyLower);

            if (hasCodeChanges && !hasTestChanges && !mentionsTestsExplicitly) {
              issues.push('üß™ No test files changed. Did you add/update tests?');
            }

            // Post comment if issues found
            if (issues.length > 0) {
              const existingComments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
              });

              const botComment = existingComments.data.find(
                comment => comment.user.type === 'Bot' && comment.body.includes('PR Quality Check')
              );

              const commentBody = `## üìã PR Quality Check\n\n${issues.join('\n')}`;

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: commentBody
                });
              }
            }
